<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>二叉树 | Lu Jingxiang's blog</title><meta name="author" content="Lu Jingxiang"><meta name="copyright" content="Lu Jingxiang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="树 二叉树性质：叶子节点个数为度为2节点个数+1 的证明过程  树的性质  度与边的关系     二叉树性质：  若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有 (i&gt;0)个结点 若规定只有根结点的二叉树的深度为1，则深度为K的二叉树的最大结点数是 (k&gt;&#x3D;0) 对任何一棵二叉树, 如果其叶结点个数为 n0, 度为2的非叶结点个数为 n2,则有n0＝n2＋1 具有n">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://example.com/2024/02/04/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="Lu Jingxiang&#39;s blog">
<meta property="og:description" content="树 二叉树性质：叶子节点个数为度为2节点个数+1 的证明过程  树的性质  度与边的关系     二叉树性质：  若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有 (i&gt;0)个结点 若规定只有根结点的二叉树的深度为1，则深度为K的二叉树的最大结点数是 (k&gt;&#x3D;0) 对任何一棵二叉树, 如果其叶结点个数为 n0, 度为2的非叶结点个数为 n2,则有n0＝n2＋1 具有n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2024-02-04T15:29:22.000Z">
<meta property="article:modified_time" content="2024-02-22T08:53:47.078Z">
<meta property="article:author" content="Lu Jingxiang">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/02/04/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二叉树',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-22 16:53:47'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Lu Jingxiang's blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Lu Jingxiang's blog"><span class="site-name">Lu Jingxiang's blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二叉树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-04T15:29:22.000Z" title="发表于 2024-02-04 23:29:22">2024-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-22T08:53:47.078Z" title="更新于 2024-02-22 16:53:47">2024-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二叉树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><hr>
<p>二叉树性质：叶子节点个数为度为2节点个数+1 的证明过程</p>
<ol>
<li><p>树的性质</p>
</li>
<li><p>度与边的关系</p>
</li>
</ol>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240129094730.png" alt="CT-20240129094730" style="zoom:67%;" />

<p>二叉树性质：</p>
<ol>
<li>若规定根结点的层数为1，则一棵非空二叉树的第i层上最多有 (i&gt;0)个结点</li>
<li>若规定只有根结点的二叉树的深度为1，则深度为K的二叉树的最大结点数是 (k&gt;&#x3D;0)</li>
<li>对任何一棵二叉树, 如果其叶结点个数为 n0, 度为2的非叶结点个数为 n2,则有n0＝n2＋1</li>
<li>具有n个结点的完全二叉树的深度k为 上取整</li>
<li>对于具有n个结点的完全二叉树，如果按照从上至下从左至右的顺序对所有节点从0开始编号，则对于序号为i<br>的结点有：<br>若i&gt;0，双亲序号：(i-1)&#x2F;2；i&#x3D;0，i为根结点编号，无双亲结点<br>若2i+1&lt;n，左孩子序号：2i+1，否则无左孩子<br>若2i+2&lt;n，右孩子序号：2i+2，否则无右孩子</li>
</ol>
<p>题目：</p>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240129100005.png" style="zoom:67%;" />

<p>思路： 完全二叉树 节点为偶数个 根据计算二叉树的节点个数性质来算 度为1的个数应该为1 因为有一个根节点和一个节点组成偶数</p>
<p>2n &#x3D; n0 +1 +n2 &amp;&amp; n0 &#x3D; n2+1 那所以叶子节点的个数n0 &#x3D; n 选A</p>
<p>总结：有偶数个节点的完全二叉树 一定会有一个度为1的节点</p>
<p>题目：</p>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240129100702.png" alt="CT-20240129100702 " style="zoom:67%;" />

<p>奇数个节点 那么不存在度为1的节点</p>
<p>那所以 n0 &#x3D; n2+1 那么叶子节点的个数就为384 选B</p>
<p>题目：</p>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240129101030.png" alt="CT-20240129101030 " style="zoom:67%;" />

<p>[log(532) ] (向上取整) 为10 选B</p>
<p>注意：要拿二叉树的性质来做题！！！</p>
<hr>
<p>前序遍历</p>
<p>中序遍历</p>
<p>后序遍历</p>
<p>层序遍历（需要借助队列 – 广度遍历）</p>
<p>题目：根据前序遍历和中序遍历求二叉树</p>
<p><img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240129122124.png" alt="CT-20240129122124"></p>
<p>重建二叉树：</p>
<p>​				1</p>
<p>​			    &#x2F;	 \</p>
<p>​			2		3</p>
<p>​		   &#x2F;         	&#x2F;	\</p>
<p>​		4		  5	   6</p>
<p>​		   \			    &#x2F;</p>
<p>​		      7		       8</p>
<p>后序遍历： 7 4 2 5 8 6 3 1</p>
<p>根据前序和后序遍历结果不能创建一棵二叉树（只能确定根的位置）</p>
<p>根据前序和中序 后序和中序可以创建一棵二叉树（必须给一个中序才能确定左右）</p>
<hr>
<p><strong>树的问题解决思路都可以用递归：也就是把一个大问题拆成小问题解决</strong></p>
<p>size() 思路 ：前序&#x2F;中序&#x2F;后序遍历 会把每个节点都遍历到 遍历一个节点就计数一次</p>
<p>​			子问题的思路 要算root总共有多少个节点 就是自己 + 左边 +右边</p>
<p>leavesCount() 思路 ：跟上面类似 有两种思路：遍历&#x2F;子问题</p>
<p>​				遍历：定义一个成员变量 返回值void 每次++</p>
<p>​				子问题： 把问题看成求左树叶子+右树叶子</p>
<p>levelNodeCnt()思路：root这棵树的第K层 &#x3D; root.left第K-1层 + root.right第k-1层,一直到k为1时停止</p>
<p>getHeight()思路：拆解成子问题来看：一棵树的高度其实就是它的最大深度，找左和右哪个大就是哪个，还要加上本身1</p>
<p>注意：leetcode 超时错误有几种情况：</p>
<pre><code>1. 死循环 2. 递归条件错误 3. 规定1ms内完成 用的时间超过了这个数
</code></pre>
<hr>
<p>OJ题：</p>
<ol>
<li><p>判断两棵树是否相同：（内容相同 结构相同）</p>
<p>时间复杂度 min（n,m)</p>
<p>本质 就是遍历二叉树 建议还是采用前序遍历的方式 根 左 右</p>
</li>
</ol>
<p>​	不同的情况：一棵树为空 一棵树不为空</p>
<p>​				两棵树对应节点的值不一样</p>
<ol start="2">
<li>一棵树是否是另一棵树的子树<ol>
<li>根节点和subRoot是不是相同的</li>
<li>subRoot是不是 root.left 子树,是不是 root.right右树</li>
<li>就是定位 + 判断是否相同(注意判空)</li>
<li>时间复杂度为O（r*s）</li>
</ol>
</li>
<li>翻转二叉树：把一棵二叉树除根节点以外所有节点左右翻转</li>
</ol>
<p>​	思路：修改节点的指向</p>
<p>​		tmp &#x3D; 左子树引用</p>
<p>​		左子树引用 &#x3D; 右子树引用</p>
<p>​		右子树引用 &#x3D; tmp</p>
<p>​	每一颗子树 交换左右孩子的指向</p>
<p>​	遍历这棵二叉树的每一个节点</p>
<ol start="4">
<li>判断一棵二叉树是否是平衡二叉树（&#x3D;&#x3D;字节跳动面试题！！！&#x3D;&#x3D;）</li>
</ol>
<p>​	平衡二叉树定义：一棵二叉树每个节点的左右两个子树的高度差的绝对值不超过1</p>
<p>​	结论：只有每一棵树都是高度平衡的，才能说这棵树是高度平衡的</p>
<p>​	左右子树高度差不超过1 并且 左树也是平衡的 右树也是平衡的 才能够说明这棵树是平衡的</p>
<p>​	简单思路 ：每当遍历到某个节点的时候就调用getHeight求左右子树的高度，但是这样做是有问题的！！！因			    为这样做的话就造成了重复计算高度，次数会变多，&#x3D;&#x3D;复杂度会达到O(n^2)&#x3D;&#x3D;，&#x3D;&#x3D;时间性能大大降低&#x3D;&#x3D;</p>
<p>​	进阶：我们要在求高度的时候 就同步进行平衡的判断,如果不平衡就返回一个标志数（这里取-1，因为逻辑上说高度不可能为-1），而且求左右子树高度的时候要注意如果不平衡了要向上传递，也就是结果为-1时也要返回-1，如此一来时间复杂度会降低为O(n)</p>
<ol start="5">
<li>&#x3D;&#x3D;对称二叉树（这题自己的思路错了 没写出来 注意！！！）&#x3D;&#x3D;</li>
</ol>
<p>​	对称：这里指轴对称</p>
<p>​	思路：就是每次比较都找到轴对称的对应位置的两个元素进行比较，除了根节点之外都要进行比较，那么这里要重新定义一个具有两个参数的方法，然后还要指定递归的方向，因为二叉树的神奇特性，我们一次定义好递归的方向 也即 左左和右右 左右和右左比较 就可以满足全部节点的比较</p>
<p>​        具体如果想不明白就用代码和图来对照看看</p>
<ol start="6">
<li><p>二叉树的构建及遍历</p>
<p>以前序遍历的方式创建二叉树</p>
<p>这里博哥的处理指向字符串字符的指针的方法是定义一个成员变量在外部，避免出现静态只有一份的问题（多个测试用例会出现问题，因为i值会变）</p>
<p>并不是一个完美的方法，这里自己在写题时还是用数组的方法为好，思路更加清晰</p>
</li>
<li><p>二叉树的分层遍历：（&#x3D;&#x3D;中等难度题&#x3D;&#x3D;）</p>
</li>
</ol>
<p>​	层序遍历 用队列 第一次插入root 然后每次弹出一个 把这个节点的两个子树按照左右的顺序放入队列</p>
<p>​	leetcode OJ:返回值为List&lt;List<Integer>&gt;形式 </p>
<p>​	&#x3D;&#x3D;这题很重要！！！早上做了我一个小时，最后怎么想都是错的，原因就在我没有体会到层序遍历思想的精髓！！！脑子里也没有清晰的层序遍历每个时段队列的状态如何！！！&#x3D;&#x3D;</p>
<p>​	重新体会一下分层遍历的思想（也就是层序遍历）</p>
<p>​	首先 是采用循环的形式 循环条件为队列不为空 那么一开始我们要先把根节点放入队列中</p>
<p>​	然后 我们可以惊奇的发现 当上一层结束之后 队列里面是刚刚好都是下一层的节点的 因为在上一层的循环当中 只能够插入上一层节点的左右子节点 孙节点完全不会涉及 那么这里就给我们已经提供好了当前一层的节点个数（也就是上一层结束时队列中元素的个数），&#x3D;&#x3D;这是层序遍历思想的精髓！！！&#x3D;&#x3D;，就是因为没想到这点，浪费了整个上午的时间，人都搞傻了</p>
<p>​	那么我们就可以知道，创建新的一个一维线性表的时机就是在上一层结束下一层开始之时，另外我们还要抽离出该层节点操作的代码，放到一个新的循环当中（因为此时我们已经可以知道该层的非空节点到底有多少个），结束循环也就是已经装配好该层的结果线性表之后，就把这个一维线性表放到大的线性表中</p>
<p>最终结束的条件仍然是队列为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;TreeNode&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;TreeNode&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//求一下当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//出队列4次 相当于把这一层的节点 都出队了</span></span><br><span class="line">            <span class="keyword">while</span> (size-- != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>好好体会这段代码！！！</p>
<p>结论：学数据结构还是要多画图多走代码理解啊！！！</p>
<ol start="8">
<li>判断一棵树是否是完全二叉树：</li>
</ol>
<p>​	从层序遍历结果来看 如果我们把null也插入队列当中 那么可以知道如果队列中出现了一个null 按照完全二叉树的定义来说 它后面就不能再是 非null的元素 了 那么其实就是 我们把第一个null节点弹出之后 如果后面弹出了非null元素 那么就不是完全二叉树 （其实完全二叉树的定义也就是层序的）</p>
<ol start="9">
<li>给出一棵二叉树，找到该树中两个指定节点的最近公共祖先</li>
</ol>
<p>​	<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/CT-20240131110120.png" alt="CT-20240131110120"></p>
<p>把大问题分解成子问题：要找公共节点，其实就三种情况 ，一个是一个为root，一个不为root，此时返回root即可，一个是一个在左，一个在右，此时返回最近的公共节点也就是这个根本身，最后是两个在同一边，就返回比较高的那个节点，也就是找到其中一个就一路向上返回</p>
<p>所以其实比较的代码就是深度搜索分解到一个个节点值的比较 然后再找它的左右子树 为null时就返回null</p>
<p>第二种思路：</p>
<p>​	如果二叉树保存了父亲节点的地址 ， 那么可以认为 这个题就是求链表的相交节点 （最快的方法）</p>
<p>​	实现方式：把从根节点到指定节点的路径上的所有节点都存起来（用栈）</p>
<p>​	最大的拦路虎是：如何找到根节点到指定节点路径上的所有节点</p>
<p>​	大问题化小问题</p>
<p>​	在方法外定义一个栈,如果要找的节点为空节点 或者 树为空 直接返回false 即可 </p>
<p>​	不为空就要入栈当前的根节点</p>
<p>​	如果根就是 要找的节点 就是找到了 向上返回 true</p>
<p>​	当前节点不是 就往左右子树找 找到的话就会返回 true 接收到的变量为true 就要立刻向上返回 不用再走进右树判断了 没找到（也就是到了叶子之后都找不到 就返回false了）</p>
<p>最后判断左右子树中间一个有无找到 找到的话就返回 没找到就弹出栈之后（也就是回退操作）返回false</p>
<ol start="10">
<li>根据前序&#x2F;后序遍历结果 中序遍历结果（无#）创建二叉树</li>
</ol>
<p>​	核心思想：两个数组 两个指针</p>
<p>​	前序数组指针从0开始 按照前序遍历递归思想创建树 每次就找到 中序遍历数组中根节点的位置 创建节点 然后创建左右子树 划定范围创建 每一次查找范围缩小 直到出现不正常的情况ie&lt;ib时返回 不再创建</p>
<p>​	后续数组指针从最后一位开始，根据后序遍历的结果形式可以知道，后序指针从后往前移，那么创建子树时也是要先创建右子树 再创建左子树</p>
<ol start="11">
<li>（最难）树的字符串表示</li>
</ol>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE.png" alt="二叉树字符串题目" style="zoom:50%;" />

<p>左边为空 但是 右边不为空 :（）</p>
<img src="https://markdownphotos.oss-cn-shenzhen.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A2%98%E7%9B%AE2.png" alt="二叉树字符串题目2" style="zoom:50%;" />

<p>思路：大问题拆成小问题考虑</p>
<p>在大函数当中首先排除掉整棵树都为null的情况</p>
<p>遍历到每个节点时 有 几种情况 ，首先如果为空 加上右括号并返回（这里我们指定只有左为空右不为空的情况才能够进入） ，若当前节点不为空输出节点的值，递归部分：左有树或者左为空右不为空时进入创建左子树字符串，右有树时才可进入创建右子树字符串，否则不给进入（题目分析出来的要求），最后还要判断当前的节点是否为第二层 因为第二层退回到第一层时不用加“)”</p>
<p>总思路就是分成左为空 右不为空 左不为空 右为空 左右都不为空 左右都为空情况来考虑</p>
<ol start="12">
<li>非递归实现二叉树的前序遍历</li>
</ol>
<p>思路：因为递归也是运用了栈桢，同属栈的思想，那么我们这里可以运用栈来解决</p>
<p>主要的思想：以向左走为主 如果左边没有了才走右边 每个节点都是如此 左边没有的时候要弹出</p>
<p>定义一个cur指针 一个top指针 cur指针没有了去找top指针的右边赋值给新的cur 然后要验证 cur不为null时才能加入栈中 同时也加入遍历结果当中</p>
<ol start="13">
<li>非递归实现二叉树的中序遍历</li>
</ol>
<p>思路与前序不同的是 只有找到最后null时才输出并弹出 然后换到栈顶的右子树 思路一致</p>
<p>其实写法大致相同 就是输出结果的时机不一样</p>
<ol start="14">
<li>非递归实现二叉树的后序遍历</li>
</ol>
<p>思路又不同的是 左边到null了不能弹出 因为还没有到输出该结果的时机 所以此时只能瞄一眼 而是要向右边去找 不断找到null 为止</p>
<p>还要创建一个标识prev 表示这个元素已经打印 prev只用记住上一个打印的节点是谁即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test0118;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.source.tree.Tree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.plaf.RootPaneUI;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAMultiPrimePrivateCrtKey;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">char</span> val;</span><br><span class="line">        <span class="keyword">private</span> TreeNode left;</span><br><span class="line">        <span class="keyword">private</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">char</span> val)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;(&quot;</span>+val+<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把二叉树按照树的形状打印在控制台上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInShape</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> getHeight(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">int</span>) Math.pow(<span class="number">2</span>,depth-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;depth;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            height+=len;</span><br><span class="line">            len/=<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        height+=depth;</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> height*<span class="number">2</span>;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[height][width];</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> width/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        printOnBoard(root,board,x,y,length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;width;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(board[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归调用改变数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 当前根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> board 画板二维数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 当前横坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 当前纵坐标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length 当前连接线的长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printOnBoard</span><span class="params">(TreeNode t,<span class="type">char</span>[][] board,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[y][x] = t.val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(t.left!=<span class="literal">null</span>)</span><br><span class="line">                board[y+i][x-i] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(t.right!=<span class="literal">null</span>)</span><br><span class="line">                board[y+i][x+i] = <span class="string">&#x27;\\&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        printOnBoard(t.left,board,x-length-<span class="number">1</span>,y+length+<span class="number">1</span>,length/<span class="number">2</span>);</span><br><span class="line">        printOnBoard(t.right,board,x+length+<span class="number">1</span>,y+length+<span class="number">1</span>,length/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BinaryTree</span><span class="params">(String treeStr)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Integer []index = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        root = createTree(treeStr,index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自己手动创建一颗二叉树（样例）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createTree</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">D</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">E</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">F</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">G</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;G&#x27;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">H</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="string">&#x27;H&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        A.left = B;</span><br><span class="line">        A.right = C;</span><br><span class="line">        B.left = D;</span><br><span class="line">        B.right = E;</span><br><span class="line">        E.right = H;</span><br><span class="line">        C.left = F;</span><br><span class="line">        C.right = G;</span><br><span class="line"></span><br><span class="line">        root = A;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前序遍历序列创建二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTree</span><span class="params">(String treeStr,Integer[] index)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(treeStr.charAt(index[<span class="number">0</span>]) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            index[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(treeStr.charAt(index[<span class="number">0</span>]++));</span><br><span class="line">        t.left = createTree(treeStr,index);</span><br><span class="line">        t.right = createTree(treeStr,index);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 每次遍历树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preOrderTraverse</span><span class="params">(TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.print(t.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderTraverse(t.left);</span><br><span class="line">        preOrderTraverse(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 每次遍历树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">midOrderTraverse</span><span class="params">(TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        midOrderTraverse(t.left);</span><br><span class="line">        System.out.print(t.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        midOrderTraverse(t.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 每次遍历树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postOrderTraverse</span><span class="params">(TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        postOrderTraverse(t.left);</span><br><span class="line">        postOrderTraverse(t.right);</span><br><span class="line">        System.out.print(t.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 树的根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要借助队列来实现</span></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">            System.out.print(node.val+<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> node.left;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> node.right;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(left!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                que.offer(left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(right!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                que.offer(right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将前序遍历结果放到一个List集合中返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存储前序遍历结果的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">preOrder</span><span class="params">(TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(t);</span><br><span class="line">        list.addAll(preOrder(t.left));</span><br><span class="line">        list.addAll(preOrder(t.right));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取树的节点的个数</span></span><br><span class="line"><span class="comment">     * 子问题思路：每棵树的节点个数为 ： 自己（1）+左子树节点个数+右子树节点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+size(root.left)+size(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回叶子节点的个数 与数节点个数相似</span></span><br><span class="line"><span class="comment">     * 思路：每棵树的叶子节点个数为 左子树叶子节点个数+右子树叶子节点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前树所含叶子节点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">leavesCount</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leavesCount(root.left)+leavesCount(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取第k层节点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k 指定的层数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 某层节点的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">levelNodeCnt</span><span class="params">(TreeNode root,<span class="type">int</span> k)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> levelNodeCnt(root.left,k-<span class="number">1</span>)+levelNodeCnt(root.right,k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用子问题拆解的思路求树的高度</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前树的深度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+(Math.max(getHeight(root.left), getHeight(root.right)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检测值为value的元素是否存在</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 当前树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在true 不存在false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">find</span><span class="params">(TreeNode root,<span class="type">char</span> val)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.val == val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(find(root.left,val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find(root.right,val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断该树是不是完全二叉树</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 该树的根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 是完全二叉树 false 不是完全二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//特殊的层序遍历 把null也收入结果当中</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                que.offer(node.left);</span><br><span class="line">                que.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!que.isEmpty() &amp;&amp; que.peek() != <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;TreeNode&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;List&lt;TreeNode&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        que.offer(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!que.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//求一下当前队列的大小</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> que.size();</span><br><span class="line">            List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//出队列size次 相当于把这一层的节点 都出队了</span></span><br><span class="line">            <span class="keyword">while</span> (size-- != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">                list.add(node);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    que.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 找到root到node之间路径上的所有节点 存储到stack中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 指定节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">getPath</span><span class="params">(TreeNode root, TreeNode node,Stack&lt;TreeNode&gt; stack)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> ||node == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leftVal</span> <span class="operator">=</span> getPath(root.left,node,stack);</span><br><span class="line">        <span class="keyword">if</span>(leftVal)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rightVal</span> <span class="operator">=</span> getPath(root.right,node,stack);</span><br><span class="line">        <span class="keyword">if</span>(rightVal)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stack.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">commonAncestor</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//思路2:除了本身递归的方法来判断，还可以找到路径,两个栈的交点，就是要找的最近共同祖先</span></span><br><span class="line">        <span class="comment">//这种思路更加直接，难点就在于题目往往定义的节点的类型是无父亲节点的，那么此时我们就要通过栈来实现这一功能</span></span><br><span class="line">        Stack&lt;TreeNode&gt; pathA = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(!getPath(root,p,pathA))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; pathB = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(!getPath(root,q,pathB))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeA</span> <span class="operator">=</span> pathA.size();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeB</span> <span class="operator">=</span> pathB.size();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> sizeA - sizeB;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(dis&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pathA.pop();</span><br><span class="line">            dis--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(dis&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            pathB.pop();</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!pathA.empty() &amp;&amp; !pathB.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">nodeA</span> <span class="operator">=</span> pathA.pop();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">nodeB</span> <span class="operator">=</span> pathB.pop();</span><br><span class="line">            <span class="keyword">if</span>(nodeA == nodeB)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nodeA;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//index 这里 定义为成员变量 或者用数组的形式进行传参</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTree</span><span class="params">(<span class="type">int</span> ib,<span class="type">int</span> ie,String preOrder,String midOrder,<span class="type">int</span> []index)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 没有左树 或者 没有右树</span></span><br><span class="line">        <span class="keyword">if</span>(ib&gt;ie)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等于的时候 还可能是单独一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点 创建</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> getRi(preOrder, midOrder, index);</span><br><span class="line">        <span class="keyword">if</span>(ri == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preOrder.charAt(index[<span class="number">0</span>]++));</span><br><span class="line">        <span class="comment">//创建左子树 右子树</span></span><br><span class="line">        root.left = createTree(ib,ri-<span class="number">1</span>,preOrder,midOrder,index);</span><br><span class="line">        root.right = createTree(ri+<span class="number">1</span>,ie,preOrder,midOrder,index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRi</span><span class="params">(String preOrder, String midOrder, <span class="type">int</span>[] index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ri;</span><br><span class="line">        <span class="keyword">for</span> (ri = <span class="number">0</span>; ri &lt; midOrder.length(); ri++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(preOrder.charAt(index[<span class="number">0</span>]) == midOrder.charAt(ri))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ri;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据中序遍历和后序遍历结果创建树</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">createTreeBy</span><span class="params">(<span class="type">int</span> ib,<span class="type">int</span> ie,String postOrder,String midOrder,<span class="type">int</span> []index)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1. 没有左树 或者 没有右树</span></span><br><span class="line">        <span class="keyword">if</span>(ib&gt;ie)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//等于的时候 还可能是单独一个节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点 创建</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ri</span> <span class="operator">=</span> getRiBy(postOrder, midOrder, index);</span><br><span class="line">        <span class="keyword">if</span>(ri == -<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postOrder.charAt(index[<span class="number">0</span>]--));</span><br><span class="line">        <span class="comment">//创建左子树 右子树</span></span><br><span class="line">        root.right = createTreeBy(ri+<span class="number">1</span>,ie,postOrder,midOrder,index);</span><br><span class="line">        root.left = createTreeBy(ib,ri-<span class="number">1</span>,postOrder,midOrder,index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getRiBy</span><span class="params">(String postOrder, String midOrder, <span class="type">int</span>[] index)</span> &#123;</span><br><span class="line">        <span class="type">int</span> ri;</span><br><span class="line">        <span class="keyword">for</span> (ri = <span class="number">0</span>; ri &lt; midOrder.length(); ri++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(postOrder.charAt(index[<span class="number">0</span>]) == midOrder.charAt(ri))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> ri;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tree2str</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getRes(root,sb,root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getRes</span><span class="params">(TreeNode root,StringBuilder sb,TreeNode t)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sb.append(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            getRes(root.left,sb,t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            getRes(root.right,sb,t);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t!=root)</span><br><span class="line">            sb.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Character&gt; <span class="title function_">preNoRecursive</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用栈模拟栈桢的处理递归过程</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode top;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || cur!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//优先向左走 一直走到没有再向右走</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                list.add(cur.val);</span><br><span class="line"></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top = stack.pop();</span><br><span class="line">            cur = top.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Character&gt; <span class="title function_">midNoRecursive</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印时机与前序遍历不同，到为null才打印</span></span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用栈模拟栈桢的处理递归过程</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode top;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || cur!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//优先向左走 一直走到没有再向右走</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line"></span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            top = stack.pop();</span><br><span class="line">            list.add(top.val);</span><br><span class="line">            cur = top.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Character&gt; <span class="title function_">postNoRecursive</span><span class="params">(TreeNode root)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打印时机与前序中序不同，要左右都结束之后才能打印 还要用一个变量记住上一个打印的节点 不然可能会造成死循环重复打印</span></span><br><span class="line">        List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//利用栈模拟栈桢的处理递归过程</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode top,prev = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!stack.empty() || cur!= <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//优先向左走 一直走到没有再向右走</span></span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不能pop，这里要peek</span></span><br><span class="line">            top = stack.peek();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//找到右边都没有了才是全部都看完了</span></span><br><span class="line">            <span class="keyword">if</span>(top.right == <span class="literal">null</span> || top.right == prev)</span><br><span class="line">            &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="comment">//此时打印,要记次节点为下一个待打印的节点的上一个节点 不然会一直死循环 因为该节点为上一节点的右节点</span></span><br><span class="line">                <span class="comment">//所以上一个节点的右节点是始终都不会为空的 所以此时要标记 避免还是进入else的部分</span></span><br><span class="line">                list.add(top.val);</span><br><span class="line">                prev = top;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur = top.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//前序遍历结果</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">treeStr</span> <span class="operator">=</span> <span class="string">&quot;ABDH###EJ###CF##G##&quot;</span>;</span><br><span class="line">        <span class="comment">//根据前序遍历结果创建树</span></span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(treeStr);</span><br><span class="line">        <span class="comment">//前序遍历，无返回值版</span></span><br><span class="line">        tree.preOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//将树可视化打印到控制台上</span></span><br><span class="line">        System.out.println(<span class="string">&quot;===========将树可视化打印到控制台上==========&quot;</span>);</span><br><span class="line">        tree.displayInShape();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============分割线==============&quot;</span>);</span><br><span class="line">        <span class="comment">//前序遍历，返回值为前序遍历顺序的集合List</span></span><br><span class="line">        System.out.println(<span class="string">&quot;根据前序遍历结果字符串创建树：&quot;</span>+treeStr);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历结果为：&quot;</span>+tree.preOrder(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;树中节点的个数为：&quot;</span>+tree.size(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;树中所含叶子节点个数为：&quot;</span>+tree.leavesCount(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;树中第3层所含节点个数为：&quot;</span>+tree.levelNodeCnt(tree.root, <span class="number">3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度为：&quot;</span>+tree.getHeight(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;树中是否包含元素E：&quot;</span>+tree.find(tree.root, <span class="string">&#x27;E&#x27;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;是否是完全二叉树：&quot;</span>+tree.isCompleteTree(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;===============分割线==============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的层序遍历结果为：&quot;</span>+tree.levelOrder(tree.root));</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        tree.getPath(tree.root,tree.root.left.left.left,stack);</span><br><span class="line">        System.out.println(<span class="string">&quot;从根节点到H的路径为：&quot;</span>+stack);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">D</span> <span class="operator">=</span> tree.root.left.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">F</span> <span class="operator">=</span> tree.root.right.left;</span><br><span class="line">        System.out.println(<span class="string">&quot;D与F的公共节点为：&quot;</span>+tree.commonAncestor(tree.root,D,F));</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">preOrder</span> <span class="operator">=</span> <span class="string">&quot;EFHIGJK&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">midOrder</span> <span class="operator">=</span> <span class="string">&quot;HFIEJKG&quot;</span>;</span><br><span class="line">        <span class="type">int</span> []index = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        tree1.root = tree1.createTree(<span class="number">0</span>,preOrder.length()-<span class="number">1</span>,preOrder,midOrder,index);</span><br><span class="line">        System.out.println(tree1.preOrder(tree1.root));</span><br><span class="line">        tree1.displayInShape();</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">postOrder</span> <span class="operator">=</span> <span class="string">&quot;BDECA&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="string">&quot;BADCE&quot;</span>;</span><br><span class="line">        <span class="type">int</span> []index1 = &#123;mid.length()-<span class="number">1</span>&#125;;</span><br><span class="line">        tree2.root = tree2.createTreeBy(<span class="number">0</span>,index1[<span class="number">0</span>],postOrder,mid,index1);</span><br><span class="line">        tree2.displayInShape();</span><br><span class="line">        System.out.println(<span class="string">&quot;===============分割线==============&quot;</span>);</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>(<span class="string">&quot;124###3##&quot;</span>);</span><br><span class="line">        System.out.println(tree3.tree2str(tree3.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;===============分割线==============&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历非递归检验：&quot;</span>);</span><br><span class="line">        System.out.println(tree.preOrder(tree.root));</span><br><span class="line">        System.out.println(tree.preNoRecursive(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历非递归检验：&quot;</span>);</span><br><span class="line">        tree.midOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(tree.midNoRecursive(tree.root));</span><br><span class="line">        System.out.println(<span class="string">&quot;后序遍历非递归检验：&quot;</span>);</span><br><span class="line">        tree.postOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(tree.postNoRecursive(tree.root));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BinaryTree</span> <span class="variable">tree</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BinaryTree</span>();</span><br><span class="line">        tree.createTree();</span><br><span class="line">        tree.preOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        tree.midOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        tree.postOrderTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">        tree.levelTraverse(tree.root);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Lu Jingxiang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/02/04/%E4%BA%8C%E5%8F%89%E6%A0%91/">http://example.com/2024/02/04/%E4%BA%8C%E5%8F%89%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Lu Jingxiang's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/04/missing-semester/" title="missing semester"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">missing semester</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/04/%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/" title="优先级队列"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">优先级队列</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/02/29/B%E6%A0%91/" title="B树"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-29</div><div class="title">B树</div></div></a></div><div><a href="/2024/02/18/map%E5%92%8Cset/" title="Map和Set"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-18</div><div class="title">Map和Set</div></div></a></div><div><a href="/2024/02/27/LRUCache/" title="LRUCache"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-27</div><div class="title">LRUCache</div></div></a></div><div><a href="/2024/02/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-26</div><div class="title">并查集</div></div></a></div><div><a href="/2024/02/04/%E6%8E%92%E5%BA%8F/" title="排序"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-04</div><div class="title">排序</div></div></a></div><div><a href="/2024/02/25/%E4%BD%8D%E5%9B%BE-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/" title="位图&amp;布隆过滤器&amp;海量数据"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-25</div><div class="title">位图&amp;布隆过滤器&amp;海量数据</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Lu Jingxiang</div><div class="author-info__description">Language: Java</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/1067367579"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/1067367579" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1067367579@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">树</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/29/B%E6%A0%91/" title="B树">B树</a><time datetime="2024-02-29T15:13:46.000Z" title="发表于 2024-02-29 23:13:46">2024-02-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/27/LRUCache/" title="LRUCache">LRUCache</a><time datetime="2024-02-27T03:38:08.000Z" title="发表于 2024-02-27 11:38:08">2024-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="并查集">并查集</a><time datetime="2024-02-26T11:21:40.000Z" title="发表于 2024-02-26 19:21:40">2024-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/02/25/%E4%BD%8D%E5%9B%BE-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE/" title="位图&amp;布隆过滤器&amp;海量数据">位图&amp;布隆过滤器&amp;海量数据</a><time datetime="2024-02-25T12:51:36.000Z" title="发表于 2024-02-25 20:51:36">2024-02-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/02/23/%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树"><img src="https://raw.githubusercontent.com/1067367579/picgophotos/main/img/202402231612915.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="红黑树"/></a><div class="content"><a class="title" href="/2024/02/23/%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树">红黑树</a><time datetime="2024-02-23T03:49:22.000Z" title="发表于 2024-02-23 11:49:22">2024-02-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Lu Jingxiang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>